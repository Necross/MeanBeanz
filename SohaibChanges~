Changes made by Sohaib 20th November
-------------------------------------

- timer_iProcess
- k_null_processor
- k_release_processor
- Queue.c dePQ 
	~ Was coded with wrong ideas?
	~ Two cases where we call this proc 
		# CASE 1: Dequeue the FIRST PCB found process_switch does this
		# CASE 2: Dequeue this specific PCB from this queue e.g. remove from bq [DEBUGGING/MISSING CASES?]
- Added k_terminate
		# Copy the terminating procedure from main.c into this one
- Added k_process_switch 
- Added k_context_switch (WITHOUT CODE)
		# Context saving done by???
- Added k_request_delay ---- Ask TA if request delay ->timer iProc->process or timer-> request 											delay->process?
			- What do they mean by field being set to wakeup_code??? The integer? or the msg type = wakeup_code???
			- What to do with this int?
- Changed k_send_message 
	~ It now chekcs if recieving message was blocked_on_recieve, if it was then the message is dequeued from bq and added onto the
	  rq in the appropriate place
- Added k_change_priority 
	~ Ask TA if only the priority of processes that are "READY" is to be changed or can it be in the blocked queue as well?
	~ Change priority of running process allowed? Currently protects against that!

TODO:

- In initialization, setup SIGALAM via ualarm () and map SIGALARM to k_timer_iProcess


NOTES:

- Decide on returning standard...return 1 or 0? 1 for success? 0 for failure?
-k_process_switch implementation: send in a pcb if we want to switch to a particular one
	- Send in null when we want to dequeue????? 

- Should process_switch be k_process_switch??? kernel accessible only?



Changes Made by Sohaib November 21st, 2011
------------------------------------------

- Added tuple data structure {pid, procStat, priority} (global.h)
	~ ProcTuple is a dynamic array of the tuple data structure

- Added queueSize (PCBQueue *pq) function to queue.c 
	~ Goes through all the levels in a priority queue and returns the total number of processes in the entire queue

- Added k_request_process_status
	~ Creates a new tuple
	~ Goes through kernel ready and blocked queues and populates tuple
	~ Does a k_send_message to return the tuple
	
- Added a pointer to a TUPLE in MsgENV (we need to return it in the envelope)










