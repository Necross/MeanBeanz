/*
 * main.c
 *
 *  Created on: Nov 9, 2011
 *      Author: zik
 */
#include <fcntl.h>
#include <sys/mman.h>
#include <sys/wait.h>
#include <stdio.h>
#include <fcntl.h>
#include <sys/mman.h>
#include <sys/wait.h>
#include <stdio.h>
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#include <errno.h>
#include <string.h>
#include <stdlib.h>
#include "k_rtx.h"

extern k_RTX * kernel;

void cleanup()
{
	// terminate child process(es)
	kill(kernel->kb_pid,SIGINT);

	// remove shared memory segment and do some standard error checks
	if (munmap(kernel->kb_mem, MAX_BUFFER_SIZE) == -1)
      printf("Bad munmap during cleanup\n");

	// close the temporary mmap file
    if (close(kernel->kb_fid) == -1)
      printf("Bad close of temporary mmap file during cleanup\n");

    // unlink (i.e. delete) the temporary mmap file
    if (unlink(kernel->kb_mfile) == -1)
      printf("Bad unlink during cleanup.\n");

    //Output Buffer Cleanup
    kill(kernel->crt_pid,SIGINT);

    // remove shared memory segment and do some standard error checks
    if (munmap(kernel->crt_mem, MAX_BUFFER_SIZE) == -1)
      printf("Bad munmap during cleanup\n");

    // close the temporary mmap file
    if (close(kernel->crt_fid) == -1)
      printf("Bad close of temporary mmap file during cleanup\n");

    // unlink (i.e. delete) the temporary mmap file
    if (unlink(kernel->crt_mfile) == -1)
      printf("Bad unlink during cleanup.\n");
}


//**************************************************************************
// routine to call before exiting
// This routine gets called when certain signals occur

void die(int signal)
{
	cleanup();
	printf( "\n\nSignal Received. Leaving demo ...\n" );
	exit(0);
}

// kbd_handler
// Called by signal SIGUSR1 from keyboard reader process

//Coding CRT for testing purposes
int k_crt_iProcess() {
	if(kernel->crt_buf->ok_flag == 0){
		return 0;
	}else{
		printf("crt iprocess running");
	}
}

int k_kb_iProcess() {
	if(kernel->kb_buf->ok_flag ==0){
		return 0;
	}else{
		//Memory fault?
		kernel->crt_buf->value = strcpy(kernel->kb_buf->value,kernel->crt_buf->value);
		kernel->crt_buf->ok_flag = 1;
		kernel->kb_buf->ok_flag = 0;
		return 1;
	}

}

int process_initialization(){
	//Initialize member variables
	kernel = (k_RTX *)malloc(sizeof(k_RTX));
	if(!PCBQueueInit(kernel->rq))return 0;
	if(!PCBQueueInit(kernel->bq))return 0;
	//kernel->availMsgEnvQueue = (MsgEnv *)malloc(AVAIL_MSG_ENV_SIZE * sizeof(MsgEnv));
	//for(int i=0; i<AVAIL_MSG_ENV_SIZE; i++)
	//	if(!msgEnvInit(kernel->availMsgEnvQueue[i]))
	//		return 0;
	//Starting processes
	if(!k_kb_iProcess()){
		return 0;
	}else{
		PCB * kbp;
		if(pcbInit(kbp,KB_PID,2,0,0,IS_IPROCESS)){
			return 0;
		}else{
			if(enPQ(kernel->rq,kbp,kbp->priority))
				return 0;
		}
	}

	if(!k_crt_iProcess()){
		return 0;
	}else{
		PCB * crtp;
		if(pcbInit(crtp,CRT_PID,2,0,0,IS_IPROCESS)){
			return 0;
		}else{
			if(enPQ(kernel->rq,crtp,crtp->priority))
				return 0;
		}
	}

	sigset(SIGINT,die);
	sigset(SIGBUS,die);
	sigset(SIGHUP,die);
	sigset(SIGILL,die); // illegal instruction
	sigset(SIGQUIT,die);
	sigset(SIGABRT,die);
	sigset(SIGTERM,die);
	sigset(SIGSEGV,die); // catch segmentation faults


	sigset(SIGUSR1,k_kb_iProcess);
	sigset(SIGUSR2,k_crt_iProcess);

	kernel->kb_mfile = "kb_map";
	kernel->crt_mfile = "crt_map";
}

int

int main () {

	char input[256];
	while (true) {
		scanf ("%s",input);
		printf ("%s\n", input);
	}
	return 0;


}
