/*
 * main.c
 *
 *  Created on: Nov 9, 2011
 *      Author: zik
 */
#include <fcntl.h>
#include <sys/mman.h>
#include <sys/wait.h>
#include <stdio.h>
#include <fcntl.h>
#include <sys/mman.h>
#include <sys/wait.h>
#include <stdio.h>
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#include <errno.h>
#include <string.h>
#include <stdlib.h>
#include "k_rtx.h"

void cleanup()
{
	// terminate child process(es)
	kill(in_pid,SIGINT);
	// remove shared memory segment and do some standard error checks
	if (munmap(shared_input_ptr, MAX_BUFFER_SIZE) == -1)
      printf("Bad munmap during cleanup\n");

	// close the temporary mmap file
    if (close(fidInput) == -1)
      printf("Bad close of temporary mmap file during cleanup\n");

    // unlink (i.e. delete) the temporary mmap file
    if (unlink(inputFile) == -1)
      printf("Bad unlink during cleanup.\n");

    //Output Buffer Cleanup
    kill(in_pid,SIGINT);

    // remove shared memory segment and do some standard error checks
    if (munmap(shared_output_ptr, MAX_BUFFER_SIZE) == -1)
      printf("Bad munmap during cleanup\n");

    // close the temporary mmap file
    if (close(fidOutput) == -1)
      printf("Bad close of temporary mmap file during cleanup\n");

    // unlink (i.e. delete) the temporary mmap file
    if (unlink(outputFile) == -1)
      printf("Bad unlink during cleanup.\n");
}


//**************************************************************************
// routine to call before exiting
// This routine gets called when certain signals occur

void die(int signal)
{
cleanup();
printf( "\n\nSignal Received. Leaving demo ...\n" );
exit(0);
}

// kbd_handler
// Called by signal SIGUSR1 from keyboard reader process

//Coding CRT for testing purposes
void crt_handler (int signum) {
printf ("Data was fucking output");
}


//(count <= input_buffer->size) &&
void kbd_handler(int signum) {
//UARTBuffer command;
int count = 0;
// copy input buffer
if (input_buffer->value [0] != '\0')
{
printf ("Stuff is being copied to the buffer as we speak Jim");
//Copy onto the output buffer
while ((input_buffer->value[count] != '\0') ) {
output_buffer->value[count] = input_buffer->value[count];
count++;
}
output_buffer->value[count] = '\0';
//strcpy(output_buffer->value ,input_buffer->value );
// we should parse the input string and execute the command given,
// but for now we just echo the input
//
// printf("Keyboard input was: %s\n",command.value );
output_buffer->ok_flag = 1; //telling output buffer that data is available for output
input_buffer->ok_flag = 0; // tell child that the buffer has been emptied
}

}

int process_initialization(){
	//Initialize member variables
	kernel = (k_RTX *)malloc(sizeof(k_RTX));
	if(!PCBQueueInit(kernel->rq))return 0;
	if(!PCBQueueInit(kernel->bq))return 0;
	kernel->availMsgEnvQueue = (MsgEnv *)malloc(AVAIL_MSG_ENV_SIZE * sizeof(MsgEnv));
	for(int i=0; i<AVAIL_MSG_ENV_SIZE; i++)
		if(!msgEnvInit(kernel->availMsgEnvQueue[i]))
			return 0;
	//Starting processes
	if(!k_kb_iProcess()){
		return 0;
	}else{
		PCB * kbp;
		if(pcbInit(kbp,KB_PID,2,0,0,IS_IPROCESS)){
			return 0;
		}else{
			if(enPQ(kernel->rq,kbp,kbp->priority))
				return 0;
		}
	}

	if(!k_crt_iProcess()){
		return 0;
	}else{
		PCB * crtp;
		if(pcbInit(crt,CRT_PID,2,0,0,IS_IPROCESS)){
			return 0;
		}else{
			if(enPQ(kernel->rq,crtp,crtp->priority))
				return 0;
		}
	}

	sigset(SIGINT,die);
	sigset(SIGBUS,die);
	sigset(SIGHUP,die);
	sigset(SIGILL,die); // illegal instruction
	sigset(SIGQUIT,die);
	sigset(SIGABRT,die);
	sigset(SIGTERM,die);
	sigset(SIGSEGV,die); // catch segmentation faults


	sigset(SIGUSR1,kbd_handler);
	sigset(SIGUSR2,crt_handler);


}

int

int main () {

	char input[256];
	while (true) {
		scanf ("%s",input);
		printf ("%s\n", input);
	}
	return 0;


}
